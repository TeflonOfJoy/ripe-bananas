= SpringBoot Server <sec:springboot>

== Solution
As requested by the assignment, the API that interacts with the PostgreSQL Database is written in Java using the SpringBoot framework, which is specifically designed, in addition to other things, to build RESTful APIs
So we headed to the Spring Initializr website and downloaded the .zip file containing all the necessary dependencies for developing with Spring Boot.

=== Design and Motivations
==== Dependencies:
 - *Spring Web:* First of all, we need the Spring Web library to have all the necessary tools to build a REST API
 - *PostgreSQL Driver:* Because we need to interrogate a Database (PostgreSQL), we need the Java driver, so we add it to the Gradle dependencies
 - *Spring Data JPA:* Which simplifies the development of Spring-based applications requiring data source access. Built on the Java Persistence API (JPA)
 - *Lombok:* An annotation preprocessor that simplifies the creation of classes, removing the need to write boilerplate code such as getters, setters, constructors, and overridden methods such as toString
 - *Spring Boot Actuator:* Equips the application with production ready featurs such as health, status, metrics and more, we added this because since we hosted the various parts of the Assignment in heroku for not having always the servers running in the backgroud of our laptops if we need to work only on the frontend or the banana_split server, with this dependency it is fast to check if there was an error on the server
 - *Swagger:* We used Swagger + Swagger UI for Documenting and testing the REST API.

For the design, we opted for an *MVC* pattern offered by default from SpringBoot Web:
 - *The Model layer:* Called entities and will be all the Java classes that represent the Database tables with all the fields and the relationships between the tables
 - *The Repository layer:* Consisting of the JPARepository and Service, which contains all the logic to extract from the database all the requested data. In this part, we will construct the queries with all the where clauses using Specifications and call the corresponding Repository method generated by the Java Persistence API (JPA) to execute the query on the database.
 - *The Controller layer:* This part is where the endpoint is specified with all the input parameters and response logic

=== Implementation
==== Packages
We divided all the classes into packages for modularity:
 - *banana_bean package:* The main package where we will find the Main class and all the other packages
 - *config package:* In this package, we will find all the classes for the necessary configurations, more specifically:
    - *Cors configuration:* To allow the Cross Origin calls, otherwise the routing server could not call our endpoint.
    - *OpenAPI configuration:* To configure the Swagger UI page.
 - *utility package:* Containing the Utility class, where all the common functions, procedures, variables and constants used by all the other packages are declared.
 - *entity package:* Containing the classes that represent the Database tables, fields and Relations between tables, in SpringBoot, these are called Entities.
 - *dto package:* Containing the DTO (Data Transfer Object) classes for the response, because sometimes we need a response that is different from the Entity representation.
 - *repository package:* Containing all the Repository Interfaces for JPA to extract data from the DB.
 - *specification_builders package:* Containing the static method for building Specifications (dynamic where clauses).
 - *service package:* Containing all the Service classes that construct all the Specifications, with the parameters obtained by the controllers, and build a response object after calling the Repository function.
 - *controller package:* Containing the Rest Controller endpoints that define all the parameters accepted by the endpoint and manage the responses

==== How we connected the Entities to the PostgreSQL tables
To represent in SpringBoot the Database we used the `@Entity` JPA annontation in the classes inside the `entity` package and to represent relationships we used the annontations provided by SpringBoot JPA such as `@OneToOne`, `@OneToMany` or `@ManyToMany` after we define all of the tables, fileds and relationships between tables all we need to do is to write custom functions in the repository Interface, or use the default one such as `findAll(Specifications<?> specs, Page<?> page)`, to tell JPA how to extract and how to represents data.
In some cases, we need to write some custom queries with the `@Query()` annotation in a Pseudo-SQL that will be translated into native SQL by JPA and Hibernate, or we could also write native queries (we did not write any of them)

==== Validation of input parameters
To validate the input parameters, we flagged the required ones in the endpoint function signature using the `@RequestParam()` annotation. In the Service classes, we check if those parameters respect a specific format, for example:
 - *IDs:* not lower than or equal to 0 (for the movies endpoint, we check for numbers above 1000000)
 - *Names and other required strings: * We check if they are not `null` or empty, but in this case, instead of returning null, we treat the search as the user wants to extract arbitrary records of that table

For all other parameters, we check whether they are null when we try to build the specifications. If we encounter a null or an empty string, we return a `conjunction()`, which is a where clause that is always `true` to prevent query errors and simplify API calls.

==== How we managed the responses
All of the responses uses a Pagination System with the `Page<?>` class to prevent a search that returns thousand of records and slow down the API, so instead we load several entries per Page and send it to the frontend, if the frontend need the next Page it can use the same API call but with the paramenter `page_num` incremented by 1.
The `Page<?>` class responds with a list of the requested type (`Movie`, `Actor` or `OscarAward`) in the `content` field. At the same level, various Page information can be found, such as `total_elements` and `total_pages`, which are helpful for the frontend to manage pagination.

For JSON serialisation, Spring Boot Web uses Jackson to convert a Java object into a JSON structure, so after we finished the representation of the db inside SpringBoot we started to develop the `/get_movie_details` endpoint and we put the `@JsonIgnore` annotation in all of the fileds we did not want inside the json response, however this created a little problem with the other enfpoints that we will discuss later in the report.

==== DTOs usage
We used DTOs only once in our project to retrieve the genre list. Because in the `Genre` class, there is the annotation `@JsonIgnore` next to the genre id to prevent the ID from being displayed in the get_movie_details JSON response

== Issues
During our journey into SpringBoot Web development, we encountered a significant issue that led us to 2 possible solutions.
The issue was that if we asked for a page of movies, the application would fetch all the fields in the `Movie` class and return the page. This behaviour was unacceptable because it produced a massive JSON response that was heavy to parse and not optimal. After all, if we wanted to search for a bunch of movies, we would want to load the details only after the user selects the movie they want.

=== DTOs solution (not the one we used)
The first solution we adopted was to create custom DTOs for the responses so that the responses from the endpoints `/get_movies` and `get_movies_with_actor` included only the fields in the Movie class.
However, this solution led to another problem: because we needed to serialise our data into the DTO, we lost pagination functionality, so we needed a much better solution.

=== Double Entities solution (the one we used)
This solution was to create another Entity called `BasicMovie` that contained only the basic information about the movies. With this solution, we could preserve pagination and reduce some server-side work because the `BasicMovie` class did not include all relationships across all tables in the Database.

== Requirements

=== System Requirements
We adopted Java 21 because it is a newer version of Java, similar to the one we used in other courses.
For the build system, we used Gradle.

=== Necessary SpringBoot configurations
SpringBoot manages the properties in a file inside the resource package called `application.properties`, in which are specified:
 - Database connection URL
 - Database username
 - Database password
 - OpenAPI paths
 - JPA parameters (such as lazy loading and other features)
 - add or remove debug prints

The first three voices are not directly in the file but stored in a `.env` file for privacy reasons and to avoid editing the file every time we deploy to Heroku.

== Limitations
SpringBoot, like other frameworks, offers many features, but it also sets a standard you must follow. If you need to go beyond that standard, you have to fight the framework to do the things you want or develop some workarounds, just like we did with the issue we've encountered, however if you want to make from scratch an application like this without using SpringBoot you end up writing an insane amount of code. At that point, it is much faster to work with SpringBoot, and after some time, you start to bear all the quirks and limitations it has.